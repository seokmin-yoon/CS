# 1. 리스트

## 1.1. 선형 리스트

배열을 이용하여 구현할 자료들을 논리적인 순서로 메모리에 연속 저장하는 방식의 자료 구조

- 배열: <인덱스, 값>
    - 인덱스: 자료의 순서

## 1.2. 연결 리스트

포인터를 이용하여 구현할 자료의 논리적인 순서와 메모리에 저장되는 물리적인 순서가 다르게 저장되는 방식의 자료 구조

- 노드: <원소, 주소>
    - 주소(포인터): 다음 노드의 메모리 주소

### 단순 연결 리스트
노드가 하나의 링크 필드에 의해서 다음 노드와 연결되는 리스트

### 원형 연결 리스트
단순 연결 리스트에서 마지막 노드를 리스트의 첫 번째 노드로 가리키도록 하여 원형 구조로 만든 리스트

### 이중 연결 리스트
리스트를 양쪽 방향으로 순회할 수 있도록 링크 필드를 두 개 사용하여 양방향 노드를 연결한 리스트

# 2. 스택 (Stack)
자료를 차곡차곡 쌓아 올린 형태의 자료구조
- LIFO (Last-In, First-Out)
- 삽입 연산: push, 위치: top (아래 그림의 노란 블록)
- 삭제 연산: pop, 위치: top

## 2.1. 순차 스택
배열을 이용한 스택

## 2.2. 연결 스택
연결 리스트를 이용한 스택

# 3. 큐 (Queue)
데이터를 뒤에서만 삽입하고, 앞에서만 삭제할 수 있는 구조 
- FIFO (First-In, First-Out)
- 삽입:  enqueue, 위치: rear
- 삭제: dequeue, 위치: front

## 3.1. 순차 큐
1차원 배열을 이용하여 순차적으로 연결된 큐
- rear가 배열의 마지막 인덱스에 도달하면, 배열에 빈자리가 있어도 포화 상태가 될 수 있음

## 3.2. 원형 큐
1차원 배열에서 처음과 끝을 논리적으로 연결한 큐
- 순차 큐의 잘못된 포화 상태 문제를 해결함

## 3.3. 연결 큐
노드의 양쪽에 포인터를 연결하여 구성된 큐

# 4. 데크 (Deque)
큐 두 개 중 하나를 좌우로 뒤집어서 붙인 구조로, 큐의 양쪽 끝에서 삽입과 삭제 연산을 수행

## 4.1. 순차 데크
효율적인 공간 활용을 위해 원형 큐 기반 데크
- 양쪽 끝에서 삽입, 삭제 연산을 수행하면서 오버헤드가 발생하므로 순차 자료구조는 비효율적
